/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.toolkits.callgraph;
import soot.*;
import soot.util.*;
import java.util.*;
import soot.util.queue.*;
import soot.jimple.spark.bdddomains.*;


/** Keeps track of the methods transitively reachable from the specified
 * entry points through the given call graph edges.
 * @author Ondrej Lhotak
 */
public class BDDReachableMethods
{ 
    private BDDCallGraph cg;
    private List entryPoints = new ArrayList(); 
    private BDDReader edgeSource;
    private BDDQueue reachables = new BDDQueue();
    private <method, ctxt> set = 0B;
    private BDDReader unprocessedMethods;
    private BDDReader allReachables = reachables.reader();
    public BDDReachableMethods( BDDCallGraph graph, Iterator entryPoints ) {
        this.cg = graph;
        addMethods( entryPoints );
        unprocessedMethods = reachables.reader();
        this.edgeSource = graph.newListener();
    }
    public BDDReachableMethods( BDDCallGraph graph, Collection entryPoints ) {
    	this(graph, entryPoints.iterator());
    }
    private void addMethods( Iterator methods ) {
        while( methods.hasNext() )
            addMethod( (MethodOrMethodContext) methods.next() );
    }
    private <method, ctxt> toBDD( MethodOrMethodContext m ) {
        return new {m.method()=>method, m.context()=>ctxt};
    }
    private void addMethod( MethodOrMethodContext m ) {
        <method, ctxt> bdd = toBDD(m);
        addMethod( bdd );
    }
    private void addMethod( <method, ctxt> m ) {
        <method, ctxt> addToReachables = m - set;
        set |= addToReachables;
        reachables.add( (method=>V1, ctxt=>T1) addToReachables );
    }
    public <method, ctxt> targets( <srcm, srcc, stmt, tgtm, tgtc, kind> edges ) {
        return (srcm=>, srcc=>, stmt=>, kind=>, tgtm=>method, tgtc=>ctxt) edges;
    }
    /** Causes the QueueReader objects to be filled up with any methods
     * that have become reachable since the last call. */
    public void update() {
        while(true) {
            <srcm, srcc, stmt:ST, tgtm, tgtc, kind:H2> e = edgeSource.next();
            if( e == 0B ) break;
            e &= e {srcm, srcc} >< set {method, ctxt};
            addMethod( targets(e) );
        }
        while(true) {
            <method, ctxt> m = unprocessedMethods.next();
            if( m == 0B ) break;
            <srcm, srcc, stmt, tgtm, tgtc, kind> e =
                cg.edgesOutOf( (method=>srcm, ctxt=>srcc) m );
            addMethod( targets(e) );
        }
    }
    /** Returns a QueueReader object containing all methods found reachable
     * so far, and which will be informed of any new methods that are later
     * found to be reachable. */
    public BDDReader listener() {
        return (BDDReader) allReachables.clone();
    }
    /** Returns a QueueReader object which will contain ONLY NEW methods
     * which will be found to be reachable, but not those that have already
     * been found to be reachable.
     */
    public BDDReader newListener() {
        return reachables.reader();
    }
    public boolean contains( MethodOrMethodContext m ) {
        return (set & toBDD(m)) != 0B;
    }
    /** Returns the number of methods that are reachable. */
    public int size() {
    	return set.size();
    }
}


