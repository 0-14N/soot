/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.spark.pag;
import java.util.*;

import soot.*;
import soot.jimple.*;
import soot.jimple.spark.*;
import soot.jimple.spark.builder.*;
import soot.jimple.spark.internal.*;
import soot.util.*;
import soot.util.queue.*;
import soot.toolkits.scalar.Pair;
import soot.jimple.toolkits.pointer.util.NativeMethodDriver;
import soot.jimple.spark.bdddomains.*;



/** Part of a pointer assignment graph for a single method.
 * @author Ondrej Lhotak
 */
public final class BDDMethodPAG extends AbstractMethodPAG {
    private BDDPAG pag;
    public AbstractPAG pag() { return pag; }

    public static BDDMethodPAG v( BDDPAG pag, SootMethod m ) {
        BDDMethodPAG ret = (BDDMethodPAG) G.v().MethodPAG_methodToPag.get( m );
        if( ret == null ) { 
            ret = new BDDMethodPAG( pag, m );
            G.v().MethodPAG_methodToPag.put( m, ret );
        }
        return ret;
    }
    protected BDDMethodPAG( BDDPAG pag, SootMethod m ) {
        this.pag = pag;
        this.method = m;
        this.nodeFactory = new MethodNodeFactory( pag, this );
    }

    /** Adds this method to the main PAG, with all VarNodes parameterized by
     * varNodeParameter. */
    public void addToPAG( Object varNodeParameter ) {
        if( varNodeParameter != null ) throw new RuntimeException( "NYI" );
        if( hasBeenAdded ) return;
        hasBeenAdded = true;
        pag.edgeSet |= internalEdgeSet;
        pag.edgeSet |= inEdgeSet;
        pag.edgeSet |= outEdgeSet;
        pag.stores  |= stores;
        pag.loads   |= loads;
        pag.alloc   |= alloc;
    }
    private static Numberable[] box ( Numberable n1, Numberable n2 ) {
        Numberable[] ret = { n1, n2 };
        return ret;
    }
    private static Numberable[] box ( Numberable n1, Numberable n2, Numberable n3 ) {
        Numberable[] ret = { n1, n2, n3 };
        return ret;
    }
    public void addInternalEdge( Node srcN, Node dstN ) {
        internalEdgeSet = addEdge( srcN, dstN, internalEdgeSet );
    }

    public void addInEdge( Node srcN, Node dstN ) {
        inEdgeSet = addEdge( srcN, dstN, inEdgeSet );
    }

    public void addOutEdge( Node srcN, Node dstN ) {
        outEdgeSet = addEdge( srcN, dstN, outEdgeSet );
    }

    private <src, dst> addEdge( Node srcN, Node dstN, <src:V1, dst:V2> edgeSet ) {
        if( srcN == null ) return edgeSet;
        if( srcN instanceof VarNode ) {
            if( dstN instanceof VarNode ) {
                edgeSet |= new { srcN => src, dstN => dst };
            } else {
                FieldRefNode fdst = (FieldRefNode) dstN;
                stores |= new
                    { srcN => src, fdst.getBase() => dst, fdst.getField() => fld };
            }
        } else if( srcN instanceof FieldRefNode ) {
            FieldRefNode fsrc = (FieldRefNode) srcN;
            loads |= new
                { fsrc.getBase() => src, fsrc.getField() => fld, dstN => dst };
        } else {
            alloc |= new { srcN => obj, dstN => var };
        }
        return edgeSet;
    }

    public <src:V1, dst:V2> internalEdgeSet;
    public <src:V1, dst:V2> inEdgeSet;
    public <src:V1, dst:V2> outEdgeSet;
    public <src:V1, dst:V2, fld:FD> stores;
    public <src:V1, fld:FD, dst:V2> loads;
    public <obj:H1, var:V1> alloc;

}

