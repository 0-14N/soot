/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.spark.internal;
import soot.jimple.spark.*;
import soot.jimple.spark.pag.*;
import soot.*;
import soot.util.*;
import java.util.Iterator;
import soot.util.queue.*;
import soot.Type;
import soot.options.SparkOptions;
import soot.jimple.spark.bdddomains.*;

/** A map of bit-vectors representing subtype relationships.
 * @author Ondrej Lhotak
 */
public final class BDDTypeManager extends AbstractTypeManager {
    public BDDTypeManager( BDDPAG bddpag ) {
        super(bddpag);
    }
    final public void clearTypeMask() {
        lastAllocNode = 0;
        lastVarNode = 0;
        typeMask = 0B;
        varNodeType = 0B;
        allocNodeType = 0B;
        typeSubtype = 0B;
    }
    final public void makeTypeMask() {
        if( fh == null ) {
            typeMask = 1B;
        }
        update();
    }
    final public <var:V1, obj:H1> get() {
        update();
        return typeMask;
    }

    int lastAllocNode = 0;
    int lastVarNode = 0;
    private void update() {
        if( fh == null ) return;
        System.out.println( "called update" );

        ArrayNumberer anNumb = pag.getAllocNodeNumberer();
        ArrayNumberer vnNumb = pag.getVarNodeNumberer();
        for( int j = lastAllocNode+1; j <= anNumb.size(); j++ ) {
            AllocNode an = (AllocNode) anNumb.get(j);
            newAnType |= new { an => obj, an.getType() => type };
            for( int i = 1; i <= vnNumb.size(); i++ ) {
                updatePair( (VarNode) vnNumb.get( i ), an );
            }
        }
        for( int i = lastVarNode+1; i <= vnNumb.size(); i++ ) {
            VarNode vn = (VarNode) vnNumb.get(i);
            newVnType |= new { vn => var, vn.getType() => type };
            for( int j = 1; j <= lastAllocNode; j++ ) {
                updatePair( vn, (AllocNode) anNumb.get( j ) );
            }
        }

        varNodeType |= newVnType;
        allocNodeType |= newAnType;

        <var:V1, subt:T1> tmp;
        <var:V1, obj:H1> tmp2;

        tmp = typeSubtype {supt} >< newVnType {type};
        tmp2 = allocNodeType {type} >< tmp {subt};
        typeMask |= tmp2;

        tmp = typeSubtype {supt} >< varNodeType {type};
        tmp2 = newAnType {type} >< tmp {subt};
        typeMask |= tmp2;

        newVnType = 0B;
        newAnType = 0B;

        lastAllocNode = anNumb.size();
        lastVarNode = vnNumb.size();

        tmp = 0B;
        tmp2 = 0B;
    }

    private void updatePair( VarNode vn, AllocNode an ) {
        Type vtype = vn.getType();
        Type atype = an.getType();

        <atp, dtp> pair = new { atype => atp, vtype => dtp };
        if( seenPairs != (seenPairs |= pair) ) {
            // never seen this pair of types before
            if( castNeverFails( atype, vtype ) ) {
                typeSubtype |= (atp=>subt, dtp=>supt) pair;
            }
        }
    }

    <subt:T1, supt:T2> typeSubtype;
    <var:V1, type:T1> varNodeType;
    <var:V1, type:T1> newVnType;
    <obj:H1, type:T1> allocNodeType;
    <obj:H1, type:T1> newAnType;
    <var:V1, obj:H1> typeMask;
    <atp:T1, dtp:T2> seenPairs;

}

