/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.spark.internal;
import soot.jimple.spark.*;
import soot.jimple.spark.pag.*;
import soot.*;
import soot.util.*;
import soot.util.queue.*;
import soot.Type;
import soot.options.SparkOptions;
import soot.jimple.spark.bdddomains.*;
import java.util.*;

/** A map of bit-vectors representing subtype relationships.
 * @author Ondrej Lhotak
 */
public final class BDDTypeManager extends AbstractTypeManager {
    public BDDTypeManager( BDDPAG bddpag ) {
        super(bddpag);
        bddhier = Scene.v().getOrMakeBDDHierarchy();
    }
    final public void clearTypeMask() {
        lastAllocNode = 0;
        lastVarNode = 0;
        typeMask = 0B;
        varNodeType = 0B;
        allocNodeType = 0B;
        typeSubtype = 0B;
        seenVTypes = new HashSet();
        seenATypes = new HashSet();
    }
    final public void makeTypeMask() {
        if( fh == null ) {
            typeMask = 1B;
        }
        update();
    }
    /*
    final public <var:V1, obj:H1> get() {
        update();
        return typeMask;
    }
    */
    final public <var:V1, obj:H1> get() {
        update();
        bddhier.update();
        <subt, supt> hier = bddhier.subtypeRelation();
        return varNodeType {type} <> hier {supt} {subt} <> allocNodeType {type};
    }

    int lastAllocNode = 0;
    int lastVarNode = 0;
    private void update() {
        if( fh == null ) return;

        ArrayNumberer anNumb = pag.getAllocNodeNumberer();
        ArrayNumberer vnNumb = pag.getVarNodeNumberer();

        HashSet newSeenVTypes = new HashSet();
        HashSet newSeenATypes = new HashSet();

        for( int j = lastAllocNode+1; j <= anNumb.size(); j++ ) {
            AllocNode an = (AllocNode) anNumb.get(j);
            Type antype = an.getType();
            newAnType |= new { an => obj, antype => type };
            if( !seenATypes.contains( antype ) ) newSeenATypes.add( antype );
        }

        for( int i = lastVarNode+1; i <= vnNumb.size(); i++ ) {
            VarNode vn = (VarNode) vnNumb.get(i);
            Type vntype = vn.getType();
            newVnType |= new { vn => var, vntype => type };
            if( !seenVTypes.contains( vntype ) ) newSeenVTypes.add( vntype );
        }

        seenATypes.addAll( newSeenATypes );

        for( Iterator antypeIt = seenATypes.iterator(); antypeIt.hasNext(); ) {

            final Type antype = (Type) antypeIt.next();
            for( Iterator vntypeIt = newSeenVTypes.iterator(); vntypeIt.hasNext(); ) {
                final Type vntype = (Type) vntypeIt.next();
                if( castNeverFails( antype, vntype ) ) {
                    typeSubtype |= new { antype => subt, vntype => supt };
                }
            }
        }

        for( Iterator antypeIt = newSeenATypes.iterator(); antypeIt.hasNext(); ) {

            final Type antype = (Type) antypeIt.next();
            for( Iterator vntypeIt = seenVTypes.iterator(); vntypeIt.hasNext(); ) {
                final Type vntype = (Type) vntypeIt.next();
                if( castNeverFails( antype, vntype ) ) {
                    typeSubtype |= new { antype => subt, vntype => supt };
                }
            }
        }

        seenVTypes.addAll( newSeenVTypes );

        varNodeType |= newVnType;
        allocNodeType |= newAnType;

        <var:V1, subt:T1> tmp;
        <var:V1, obj:H1> tmp2;

        tmp = typeSubtype {supt} <> newVnType {type};
        tmp2 = allocNodeType {type} <> tmp {subt};
        typeMask |= tmp2;

        tmp = typeSubtype {supt} <> varNodeType {type};
        tmp2 = newAnType {type} <> tmp {subt};
        typeMask |= tmp2;

        newVnType = 0B;
        newAnType = 0B;

        lastAllocNode = anNumb.size();
        lastVarNode = vnNumb.size();

        tmp = 0B;
        tmp2 = 0B;

        bddhier.update();
        <subt, supt> bddts = bddhier.subtypeRelation();
        bddts = bddts {supt} >< (var=>) varNodeType {type};
        bddts = bddts {subt} >< (obj=>) allocNodeType {type};
        if( bddts == typeSubtype ) {
            System.out.println( "bdd and non-bdd hierarchy match" );
        } else {
            System.out.println( "bdd and non-bdd hierarchy don't match" );
            System.out.println( "size of bdd: "+bddts.size()+" size of non-bdd: "+typeSubtype.size() );
            System.out.println( "missing pairs: " );
            System.out.println( (bddts-typeSubtype).toString() );
        }


    }

    <subt:T1, supt:T2> typeSubtype;
    <var:V1, type:T1> varNodeType;
    <var:V1, type:T1> newVnType;
    <obj:H1, type:T1> allocNodeType;
    public <obj, type> allocNodeType() { return allocNodeType; }
    <obj:H1, type:T1> newAnType;
    <var:V1, obj:H1> typeMask;
    HashSet seenVTypes = new HashSet();
    HashSet seenATypes = new HashSet();


    private BDDHierarchy bddhier;

}

