/* Soot - a J*va Optimization Framework
 * Copyright (C) 2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.spark.solver;
import soot.jimple.spark.*;
import soot.jimple.spark.pag.*;
import soot.jimple.spark.sets.*;
import soot.jimple.spark.internal.*;
import soot.*;
import soot.util.queue.*;
import java.util.*;
import soot.options.SparkOptions;
import soot.jimple.spark.bdddomains.*;

/** Propagates points-to sets along pointer assignment graph using BDDs.
 * @author Ondrej Lhotak
 */

public final class BDDPropagator extends Propagator {
    public BDDPropagator( BDDPAG pag ) { this.pag = pag; }
    /** Actually does the propagation. */
    public final void propagate() {
        <var:V1, obj:H1> oldPointsTo = 0B;
        <var:V1, obj:H1> newPointsTo = 0B;
        <var:V1, obj:H1> tmpPointsTo = 0B;

        <obj:H2, var:V1, fld:FD> objectsBeingStored;
        <obj:H2, var:V1, fld:FD> oldStorePt = 0B;
        <obj:H2, var:V1, fld:FD> newStorePt = 0B;

        <base:H1, fld:FD, obj:H2> newFieldPt = 0B;
        <base:H1, fld:FD, obj:H2> tmpFieldPt = 0B;

        // The objects pointed to by base.fld are being loaded into dst
        <base:H1, fld:FD, dst:V2> loadsFromHeap = 0B;
        <base:H1, fld:FD, dst:V2> loadAss = 0B;

        final BDDTypeManager typeManager = (BDDTypeManager) pag.getTypeManager();

        pag.pointsTo = pag.alloc;
        newPointsTo = pag.pointsTo;

        // start solving 
        do {

            // repeat rule (1) in the inner loop
            do {
                newPointsTo = (dst => var) pag.edgeSet {src} >< newPointsTo {var};
                newPointsTo -= pag.pointsTo;
                newPointsTo &= typeManager.get();
                pag.pointsTo |= newPointsTo;

                if( pag.getOpts().verbose() ) {
                    G.v().out.println( "Minor iteration: "+
                        ((obj=>)newPointsTo).size()+" changed p2sets" );
                }

            } while( newPointsTo != 0B );

            newPointsTo = pag.pointsTo - oldPointsTo;

            // apply rule (2)
            objectsBeingStored = (dst => var) pag.stores {src} >< newPointsTo {var};
                                          
            newStorePt = objectsBeingStored - oldStorePt;
            oldStorePt |= newStorePt;

            newFieldPt = oldStorePt {var} >< (obj => base) newPointsTo {var};

            tmpFieldPt = newStorePt {var} >< (obj => base) oldPointsTo {var};
            newFieldPt |= tmpFieldPt;
                                  
            newFieldPt -= pag.fieldPt;
            pag.fieldPt |= newFieldPt;

            // apply rule (3)
            loadsFromHeap = pag.loads {src} >< (obj => base) newPointsTo {var};

            loadsFromHeap -= loadAss;
                                     
            newPointsTo = (dst => var) loadAss {base,fld} >< newFieldPt {base,fld};
            tmpPointsTo = (dst => var) loadsFromHeap {base,fld} >< pag.fieldPt {base,fld};
            newPointsTo |= tmpPointsTo;

            // cache loadAss
            loadAss |= loadsFromHeap;
            
            // update oldPointsTo
            oldPointsTo = pag.pointsTo;

            // convert new points-to relation to normal type
            newPointsTo -= pag.pointsTo;
    
            // apply typeFilter
            newPointsTo &= typeManager.get();
            pag.pointsTo |= newPointsTo;

            if( pag.getOpts().verbose() ) {
                    G.v().out.println( "Major iteration: "+
                        ((obj=>)newPointsTo).size()+" changed p2sets" );
            }
        } while(newPointsTo != 0B);
    }

    /* End of public methods. */
    /* End of package methods. */

    
    protected BDDPAG pag;
    protected OnFlyCallGraph ofcg;
}



