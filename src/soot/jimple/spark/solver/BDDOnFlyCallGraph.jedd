/* Soot - a J*va Optimization Framework
 * Copyright (C) 2002,2003 Ondrej Lhotak
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

package soot.jimple.spark.solver;
import soot.jimple.*;
import soot.jimple.spark.*;
import soot.jimple.spark.sets.*;
import soot.jimple.spark.pag.*;
import soot.jimple.spark.builder.*;
import soot.jimple.toolkits.callgraph.*;
import soot.*;
import java.util.*;
import soot.util.*;
import soot.util.queue.*;
import soot.options.SparkOptions;
import soot.toolkits.scalar.Pair;
import soot.jimple.spark.bdddomains.*;
import jedd.*;


/** The interface between the pointer analysis engine and the on-the-fly
 * call graph builder.
 * @author Ondrej Lhotak
 */

public class BDDOnFlyCallGraph {
    private BDDOnFlyCallGraphBuilder ofcgb;
    private BDDReachableMethods reachableMethods;
    private BDDReader reachablesReader;
    private BDDReader callEdges;
    private BDDCallGraph callGraph;

    public BDDReachableMethods reachableMethods() { return reachableMethods; }
    public BDDCallGraph callGraph() { return callGraph; }

    public BDDOnFlyCallGraph( BDDPAG pag ) {
        this.pag = pag;
        callGraph = new BDDCallGraph();
        //Scene.v().setCallGraph( callGraph );
        BDDContextManager cm = BDDCallGraphBuilder.makeContextManager(callGraph);
        reachableMethods = new BDDReachableMethods( callGraph, Scene.v().getEntryPoints());
        ofcgb = new BDDOnFlyCallGraphBuilder( pag, cm, reachableMethods );
        reachablesReader = reachableMethods.listener();
        callEdges = cm.callGraph().listener();
    }
    public void build() {
        ofcgb.processReachables();
        processReachables();
        processCallEdges();
    }
    private void processReachables() {
        reachableMethods.update();
        while(true) {
            <method:V1, ctxt:T1> methodContexts = reachablesReader.next();
            if( methodContexts == 0B ) return;
            addToPAG( methodContexts );
        }
    }
    private void addToPAG( <method, ctxt> methodContexts ) {
        <method> methods = (ctxt=>) methodContexts;
        for( Iterator methIt = methods.iterator(); methIt.hasNext(); ) {
            final SootMethod meth = (SootMethod) methIt.next();
            AbstractMethodPAG mpag = AbstractMethodPAG.v( pag, meth );
            mpag.build();
            <ctxt> contexts = methodContexts {method} <>
                              new { meth=>method } {method};
            for( Iterator contextIt = contexts.iterator(); contextIt.hasNext(); ) {
                final Object context = (Object) contextIt.next();
                mpag.addToPAG(context);
            }
        }
    }
    private void processCallEdges() {
        Stmt s = null;
        while(true) {
            <srcm:V1, srcc:T1, stmt:ST, kind:H2, tgtm:V2, tgtc:T2> e = callEdges.next();
            if( e == 0B ) break;
            <method, ctxt> mc = 
                (srcm=>, srcc=>, stmt=>, kind=>, tgtm=>method, tgtc=>ctxt) e;
            addToPAG( mc );
            Iterator it = e.iterator( new Domain[] { srcm.v(), srcc.v(), stmt.v(),
                kind.v(), tgtm.v(), tgtc.v()} );
            while( it.hasNext() ) {
                Object[] edge = (Object[]) it.next();
                pag.addCallTarget( new Edge(
                    MethodContext.v( (SootMethod) edge[0], edge[1] ),
                    (Stmt) edge[2],
                    MethodContext.v( (SootMethod) edge[4], edge[5] ),
                    ((Integer) edge[3]).intValue() ) );
            }
        }
    }

    public BDDOnFlyCallGraphBuilder ofcgb() { return ofcgb; }

    public void updatedNodes( <var, type> types ) {
        ofcgb.addTypes( types );
        /* TODO: deal with string constants
        if( ofcgb.wantStringConstants( receiver ) ) {
            p2set.forall( new P2SetVisitor() {
            public final void visit( Node n ) {
                if( n instanceof StringConstantNode ) {
                    String constant = ((StringConstantNode)n).getString();
                    ofcgb.addStringConstant( receiver, context, constant );
                } else {
                    ofcgb.addStringConstant( receiver, context, null );
                }
            }} );
        }
        */
    }

    /** Node uses this to notify PAG that n2 has been merged into n1. */
    public void mergedWith( Node n1, Node n2 ) {
    }

    /* End of public methods. */
    /* End of package methods. */

    private BDDPAG pag;
}



