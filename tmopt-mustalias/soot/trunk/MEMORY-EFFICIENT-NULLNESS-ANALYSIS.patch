Index: /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/MemoryEfficientFixedDomain.java
===================================================================
--- /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/MemoryEfficientFixedDomain.java	(revision 0)
+++ /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/MemoryEfficientFixedDomain.java	(revision 0)
@@ -0,0 +1,328 @@
+package soot.jimple.toolkits.annotation.nullcheck;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * MemoryEfficientFixedDomain
+ *
+ * @author Eric Bodden
+ */
+public class MemoryEfficientFixedDomain  {
+
+	protected final List keys;
+	
+	protected final List values;
+	
+	protected final Map keyToIndex;
+	
+	protected final Map valToIndex;
+
+	protected final Object defaultValue;
+	
+	protected final MemoryEfficientFixedDomainMap DEFAULT_MAP;
+	
+	public MemoryEfficientFixedDomain(Collection keys, Collection values, Object defaultValue) {
+		if(!values.contains(defaultValue)) {
+			throw new IllegalArgumentException("default value not contained in values");
+		}
+		if(values.isEmpty()) {
+			throw new IllegalArgumentException("empty values set");
+		}
+
+		this.defaultValue = defaultValue;
+		this.keys = new ArrayList(keys);
+		this.values = new ArrayList(values);
+
+		Map keyToIndex = new HashMap();
+		int keyIndex = 0;
+		for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
+			keyToIndex.put(keysIter.next(), new Integer(keyIndex));
+			keyIndex++;
+		}
+		this.keyToIndex = keyToIndex;
+		
+		Map valtoIndex = new HashMap();
+		int valIndex = 0;
+		for (Iterator valsIter = values.iterator(); valsIter.hasNext();) {
+			valtoIndex.put(valsIter.next(), new Integer(valIndex));
+			valIndex++;
+		}
+		this.valToIndex = valtoIndex;
+		
+		this.DEFAULT_MAP = new MemoryEfficientFixedDomainMap();
+	}
+	
+	public Map newMap() {
+		return copyMap(DEFAULT_MAP);
+	}
+	
+	public Map copyMap(MemoryEfficientFixedDomainMap toCopy) {
+		return new MemoryEfficientFixedDomainMap(toCopy);
+	}
+
+	protected int indexOfKey(Object key) {
+		return ((Integer) keyToIndex.get(key)).intValue();
+	}
+	
+	protected int indexOfValue(Object value) {
+		return ((Integer) valToIndex.get(value)).intValue();
+	}
+	
+	
+	protected class MemoryEfficientFixedDomainMap implements Map {
+
+		private int[] backingSet;
+		
+		public MemoryEfficientFixedDomainMap() {
+			backingSet = new int[keys.size()];
+			for (int i = 0; i < backingSet.length; i++) {
+				backingSet[i] = indexOfValue(defaultValue);
+			}			
+		}
+		
+		/**
+		 * @param toCopy
+		 */
+		public MemoryEfficientFixedDomainMap(
+				MemoryEfficientFixedDomainMap toCopy) {
+			backingSet = new int[toCopy.backingSet.length];
+			System.arraycopy(toCopy.backingSet,0, backingSet, 0, toCopy.backingSet.length);
+		}
+		
+		public void copyInto(MemoryEfficientFixedDomainMap target) {
+			target.backingSet = new int[backingSet.length];
+			System.arraycopy(backingSet,0, target.backingSet, 0, backingSet.length);			
+		}
+
+		public void clear() {
+			throw new UnsupportedOperationException("A fixed size map cannot be cleared.");
+		}
+
+		public boolean containsKey(Object key) {
+			return keys.contains(key);
+		}
+
+		public boolean containsValue(Object value) {
+			throw new UnsupportedOperationException("Not implemented.");
+		}
+
+		public Set entrySet() {
+			return new EntrySet();
+		}
+
+		public Object get(Object key) {
+			return values.get(backingSet[indexOfKey(key)]);
+		}
+
+		public boolean isEmpty() {
+			return false;
+		}
+
+		public Set keySet() {
+			return new HashSet(keys);
+		}
+
+		public Object put(Object key, Object value) {
+			if(!valToIndex.containsKey(value)) {
+				throw new IllegalArgumentException("unknown value");
+			}
+
+			int indexOfKey = indexOfKey(key);
+			Object oldValue = values.get(backingSet[indexOfKey]);
+			backingSet[indexOfKey] = indexOfValue(value);
+			return oldValue;
+		}
+
+		public void putAll(Map other) {
+			for (Iterator entryIter = other.entrySet().iterator(); entryIter.hasNext();) {
+				Entry entry = (Entry) entryIter.next();
+				put(entry.getKey(),entry.getValue());
+			}
+		}
+
+		public Object remove(Object key) {
+			throw new UnsupportedOperationException("Nothing can be removed from a fixed size map.");
+		}
+
+		public int size() {
+			return backingSet.length;
+		}
+
+		public Collection values() {
+			throw new UnsupportedOperationException("Not implemented.");
+		}
+		
+		public String toString() {
+			return entrySet().toString();
+		}
+		
+		/**
+		 * {@inheritDoc}
+		 */
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result
+					+ hashCode(backingSet);
+			return result;
+		}
+		
+		/**
+		 * Returns a hash code value for the array
+		 * @param array the array to create a hash code value for
+		 * @return a hash code value for the array
+		 */
+		private int hashCode(int[] array) {
+			final int prime = 31;
+			if (array == null)
+				return 0;
+			int result = 1;
+			for (int index = 0; index < array.length; index++) {
+				result = prime * result + array[index];
+			}
+			return result;
+		}
+
+		/**
+		 * {@inheritDoc}
+		 */
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			final MemoryEfficientFixedDomainMap other = (MemoryEfficientFixedDomainMap) obj;
+			if (!Arrays.equals(backingSet, other.backingSet))
+				return false;
+			return true;
+		}		
+		
+		protected class EntrySet extends LinkedHashSet {
+			
+			protected class FixedEntry implements Entry {
+
+				protected Object key, value;
+				
+				public FixedEntry(Object key, Object value) {
+					this.key = key;
+					this.value = value;
+				}
+
+				public Object getKey() {
+					return key;
+				}
+
+				public Object getValue() {
+					return value;
+				}
+
+				public Object setValue(Object value) {
+					return put(key,value);
+				}
+				
+				public String toString() {
+					return key +"="+ value;
+				}
+				
+			}
+			
+			public EntrySet() {
+				for (Iterator keysIter = keys.iterator(); keysIter.hasNext();) {
+					Object key = keysIter.next();
+					add(new FixedEntry(key,get(key)));
+				}
+			}
+			
+		}
+
+	}
+	
+	
+	/**
+	 * A pair of a key and value. Compares keys on equality, values on identity.
+	 *
+	 * @author Eric Bodden
+	 */
+	protected static class KeyValuePair {
+		
+		protected Object key;
+		
+		protected Object value;
+
+		/**
+		 * @param key
+		 * @param value
+		 */
+		public KeyValuePair(Object key, Object value) {
+			super();
+			this.key = key;
+			this.value = value;
+		}
+
+		/**
+		 * {@inheritDoc}
+		 */
+		public int hashCode() {
+			final int prime = 31;
+			int result = 1;
+			result = prime * result + ((key == null) ? 0 : key.hashCode());
+			result = prime * result + ((value == null) ? 0 : System.identityHashCode(value));
+			return result;
+		}
+
+		/**
+		 * {@inheritDoc}
+		 */
+		public boolean equals(Object obj) {
+			if (this == obj)
+				return true;
+			if (obj == null)
+				return false;
+			if (getClass() != obj.getClass())
+				return false;
+			final KeyValuePair other = (KeyValuePair) obj;
+			if (key == null) {
+				if (other.key != null)
+					return false;
+			} else if (!key.equals(other.key))
+				return false;
+			if (value == null) {
+				if (other.value != null)
+					return false;
+			} else if (value!=other.value)
+				return false;
+			return true;
+		}
+
+		/**
+		 * @return the key
+		 */
+		public Object getKey() {
+			return key;
+		}
+
+		/**
+		 * @return the value
+		 */
+		public Object getValue() {
+			return value;
+		}
+		
+		
+	}
+
+
+	
+
+}
Index: /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/NullnessAnalysis.java
===================================================================
--- /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/NullnessAnalysis.java	(revision 2534)
+++ /home/user/ebodde/workspaces/abc/soot/src/soot/jimple/toolkits/annotation/nullcheck/NullnessAnalysis.java	(working copy)
@@ -19,6 +19,8 @@
 
 package soot.jimple.toolkits.annotation.nullcheck;
 
+import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -30,12 +32,16 @@
 import soot.Immediate;
 import soot.Local;
 import soot.RefLikeType;
+import soot.RefType;
 import soot.Unit;
 import soot.Value;
+import soot.ValueBox;
 import soot.jimple.ArrayRef;
 import soot.jimple.ClassConstant;
+import soot.jimple.Constant;
 import soot.jimple.DefinitionStmt;
 import soot.jimple.FieldRef;
+import soot.jimple.IdentityRef;
 import soot.jimple.InstanceFieldRef;
 import soot.jimple.InstanceInvokeExpr;
 import soot.jimple.InvokeExpr;
@@ -54,6 +60,7 @@
 import soot.jimple.internal.JIfStmt;
 import soot.jimple.internal.JInstanceOfExpr;
 import soot.jimple.internal.JNeExpr;
+import soot.jimple.toolkits.annotation.nullcheck.MemoryEfficientFixedDomain.MemoryEfficientFixedDomainMap;
 import soot.toolkits.graph.UnitGraph;
 import soot.toolkits.scalar.ForwardBranchedFlowAnalysis;
 
@@ -84,6 +91,22 @@
 		public String toString() {return "top";}
 	};
 	
+	/** the list of all possible values, i.e. BOTTOM, NULL, NON_NULL and TOP */
+	protected final static List VALUES;
+	
+	protected final MemoryEfficientFixedDomain domain;
+	
+	static {
+		//initialize VALUES
+		List values = new ArrayList();
+		values.add(BOTTOM);
+		values.add(NULL);
+		values.add(NON_NULL);
+		values.add(TOP);
+		VALUES = Collections.unmodifiableList(values);
+	}
+	
+	
 	/**
 	 * Creates a new analysis for the given graph/
 	 * @param graph any unit graph
@@ -90,6 +113,20 @@
 	 */
 	public NullnessAnalysis(UnitGraph graph) {
 		super(graph);
+
+
+		Set locals = new HashSet();
+
+		//find all locals and stack locals;
+		//for this it suffices to look at definition boxes, because any such local needs to eb defined
+		//before it is used; using graph.getBody().getLocals() is *not* sufficient as this does not include locals
+		//in exception handlers for some reason (?)
+		for (Iterator unitIter = graph.getBody().getDefBoxes().iterator(); unitIter.hasNext();) {
+			ValueBox defBox = (ValueBox) unitIter.next();
+			locals.add(defBox.getValue());
+		}
+		
+		domain = new MemoryEfficientFixedDomain(locals,VALUES,BOTTOM);
 		
 		doAnalysis();
 	}
@@ -98,9 +135,9 @@
 	 * {@inheritDoc}
 	 */
 	protected void flowThrough(Object flowin, Unit u, List fallOut, List branchOuts) {
-		AnalysisInfo in = (AnalysisInfo) flowin;
-		AnalysisInfo out = new AnalysisInfo(in);
-		AnalysisInfo outBranch = new AnalysisInfo(in);
+		MemoryEfficientFixedDomainMap in = (MemoryEfficientFixedDomainMap) flowin;
+		Map out = domain.copyMap(in);
+		Map outBranch = domain.copyMap(in);
 		
 		Stmt s = (Stmt)u;
 		
@@ -118,6 +155,8 @@
 			out.put(monitorStmt.getOp(), NON_NULL);
 		}
 		
+		HashMap expressions = new HashMap();
+		
 		//if we have an array ref, set the info for this ref to TOP,
 		//cause we need to be conservative here
 		if(s.containsArrayRef()) {
@@ -122,7 +161,7 @@
 		//cause we need to be conservative here
 		if(s.containsArrayRef()) {
 			ArrayRef arrayRef = s.getArrayRef();
-			handleArrayRef(arrayRef,out);
+			handleArrayRef(arrayRef,out,expressions);
 		}
 		//same for field refs, but also set the receiver object to non-null, if there is one
 		if(s.containsFieldRef()) {
@@ -127,7 +166,7 @@
 		//same for field refs, but also set the receiver object to non-null, if there is one
 		if(s.containsFieldRef()) {
 			FieldRef fieldRef = s.getFieldRef();
-			handleFieldRef(fieldRef, out);
+			handleFieldRef(fieldRef, out, expressions);
 		}
 		//same for invoke expr., also set the receiver object to non-null, if there is one
 		if(s.containsInvokeExpr()) {
@@ -132,11 +171,11 @@
 		//same for invoke expr., also set the receiver object to non-null, if there is one
 		if(s.containsInvokeExpr()) {
 			InvokeExpr invokeExpr = s.getInvokeExpr();
-			handleInvokeExpr(invokeExpr, out);
+			handleInvokeExpr(invokeExpr, out, expressions);
 		}
 		
-		//allow sublasses to define certain values as always-non-null
-		for (Iterator outIter = out.entrySet().iterator(); outIter.hasNext();) {
+		//allow sublasses to define certain expressions as always-non-null
+		for (Iterator outIter = expressions.entrySet().iterator(); outIter.hasNext();) {
 			Entry entry = (Entry) outIter.next();
 			Value v = (Value) entry.getKey();
 			if(isAlwaysNonNull(v)) {
@@ -152,27 +191,12 @@
 		if(s instanceof DefinitionStmt) {
 			//need to copy the current out set because we need to assign under this assumption;
 			//so this copy becomes the in-set to handleRefTypeAssignment
-			AnalysisInfo temp = new AnalysisInfo(out);
 			DefinitionStmt defStmt = (DefinitionStmt) s;
-			if(defStmt.getLeftOp().getType() instanceof RefLikeType) {
-				handleRefTypeAssignment(defStmt, temp, out);
-			}
+			if(defStmt.getLeftOp() instanceof Local && defStmt.getLeftOp().getType() instanceof RefType) {
+				handleRefTypeAssignment(defStmt, out, expressions);
+			} 
 		}
 		
-		//safe memory by only retaining information about locals
-		for (Iterator outIter = out.keySet().iterator(); outIter.hasNext();) {
-			Value v = (Value) outIter.next();
-			if(!(v instanceof Local)) {
-				outIter.remove();
-			}
-		}
-		for (Iterator outBranchIter = outBranch.keySet().iterator(); outBranchIter.hasNext();) {
-			Value v = (Value) outBranchIter.next();
-			if(!(v instanceof Local)) {
-				outBranchIter.remove();
-			}
-		}
-
 		// now copy the computed info to all successors
         for( Iterator it = fallOut.iterator(); it.hasNext(); ) {
             copy( out, it.next() );
@@ -193,7 +217,7 @@
 		return false;
 	}
 	
-	private void handleIfStmt(JIfStmt ifStmt, AnalysisInfo in, AnalysisInfo out, AnalysisInfo outBranch) {
+	private void handleIfStmt(JIfStmt ifStmt, Map in, Map out, Map outBranch) {
 		Value condition = ifStmt.getCondition();
 		if(condition instanceof JInstanceOfExpr) {
 			//a instanceof X ; if this succeeds, a is not null
@@ -206,8 +230,8 @@
 		} 		
 	}
 
-	private void handleEqualityOrNonEqualityCheck(AbstractBinopExpr eqExpr, AnalysisInfo in,
-			AnalysisInfo out, AnalysisInfo outBranch) {
+	private void handleEqualityOrNonEqualityCheck(AbstractBinopExpr eqExpr, Map in,
+			Map out, Map outBranch) {
 		Value left = eqExpr.getOp1();
 		Value right = eqExpr.getOp2();
 		
@@ -235,8 +259,8 @@
 		}
 	}
 
-	private void handleNonEquality(Value val, AnalysisInfo out,
-			AnalysisInfo outBranch) {
+	private void handleNonEquality(Value val, Map out,
+			Map outBranch) {
 		out.put(val, NULL);
 		outBranch.put(val, NON_NULL);
 	}
@@ -241,8 +265,8 @@
 		outBranch.put(val, NON_NULL);
 	}
 
-	private void handleEquality(Value val, AnalysisInfo out,
-			AnalysisInfo outBranch) {
+	private void handleEquality(Value val, Map out,
+			Map outBranch) {
 		out.put(val, NON_NULL);
 		outBranch.put(val, NULL);
 	}
@@ -248,7 +272,7 @@
 	}
 	
 	private void handleInstanceOfExpression(JInstanceOfExpr expr,
-			AnalysisInfo in, AnalysisInfo out, AnalysisInfo outBranch) {
+			Map in, Map out, Map outBranch) {
 		Value op = expr.getOp();
 		//if instanceof succeeds, we have a non-null value
 		outBranch.put(op,NON_NULL);
@@ -254,15 +278,15 @@
 		outBranch.put(op,NON_NULL);
 	}
 
-	private void handleArrayRef(ArrayRef arrayRef, AnalysisInfo out) {
+	private void handleArrayRef(ArrayRef arrayRef, Map locals, HashMap expressions) {
 		Value array = arrayRef.getBase();
 		//here we know that the array must point to an object, but the array value might be anything
-		out.put(array, NON_NULL);
-		out.put(arrayRef, TOP);
+		locals.put(array, NON_NULL);
+		expressions.put(arrayRef, TOP);
 	}
 
 	private void handleFieldRef(FieldRef fieldRef,
-			AnalysisInfo out) {
+			Map locals, HashMap expressions) {
 		if(fieldRef instanceof InstanceFieldRef) {
 			InstanceFieldRef instanceFieldRef = (InstanceFieldRef) fieldRef;
 			//here we know that the receiver must point to an object
@@ -267,13 +291,13 @@
 			InstanceFieldRef instanceFieldRef = (InstanceFieldRef) fieldRef;
 			//here we know that the receiver must point to an object
 			Value base = instanceFieldRef.getBase();
-			out.put(base,NON_NULL);
+			locals.put(base,NON_NULL);
 		}
 		//but the referenced object might point to everything
-		out.put(fieldRef, TOP);
+		expressions.put(fieldRef, TOP);
 	}
 
-	private void handleInvokeExpr(InvokeExpr invokeExpr,AnalysisInfo out) {
+	private void handleInvokeExpr(InvokeExpr invokeExpr,Map locals, HashMap expressions) {
 		if(invokeExpr instanceof InstanceInvokeExpr) {
 			InstanceInvokeExpr instanceInvokeExpr = (InstanceInvokeExpr) invokeExpr;
 			//here we know that the receiver must point to an object
@@ -278,14 +302,14 @@
 			InstanceInvokeExpr instanceInvokeExpr = (InstanceInvokeExpr) invokeExpr;
 			//here we know that the receiver must point to an object
 			Value base = instanceInvokeExpr.getBase();
-			out.put(base,NON_NULL);
+			locals.put(base,NON_NULL);
 		}
 		//but the returned object might point to everything
-		out.put(invokeExpr, TOP);
+		expressions.put(invokeExpr, TOP);
 	}
 
 	private void handleRefTypeAssignment(DefinitionStmt assignStmt,
-			AnalysisInfo rhsInfo, AnalysisInfo out) {
+			Map out, HashMap expressions) {
 		Value left = assignStmt.getLeftOp();
 		Value right = assignStmt.getRightOp();
 		
@@ -296,20 +320,26 @@
 		}
 		
 		if(right instanceof NewExpr || right instanceof NewArrayExpr
-		|| right instanceof NewMultiArrayExpr || right instanceof ThisRef
+		|| right instanceof NewMultiArrayExpr || right instanceof IdentityRef
 		|| right instanceof StringConstant || right instanceof ClassConstant) {
 			//if we assign new... or @this, the result is non-null
-			rhsInfo.put(right,NON_NULL);
+			expressions.put(right,NON_NULL);
 		} else if(right instanceof ParameterRef) {
 			//if we assign a parameter, we don't know anything
-			rhsInfo.put(right,TOP);
+			expressions.put(right,TOP);
 		} else if(right==NullConstant.v()) {
 			//if we assign null, well, it's null
-			rhsInfo.put(right, NULL);
+			expressions.put(right, NULL);
 		}
 		
+		Object rhsValue = (right instanceof Local) ? out.get(right) : expressions.get(right);
+		if(rhsValue==null) {
+			throw new IllegalStateException("unhandled rhs: "+right);
+		}
+		
+		
 		//assign from rhs to lhs
-		out.put(left,rhsInfo.get(right));
+		out.put(left,rhsValue);
 	}
 
 	/**
@@ -316,10 +346,9 @@
 	 * {@inheritDoc}
 	 */
 	protected void copy(Object source, Object dest) {
-		Map s = (Map) source;
-		Map d = (Map) dest;
-		d.clear();
-		d.putAll(s);
+		MemoryEfficientFixedDomainMap s = (MemoryEfficientFixedDomainMap) source;
+		MemoryEfficientFixedDomainMap d = (MemoryEfficientFixedDomainMap) dest;
+		s.copyInto(d);
 	}
 
 	/**
@@ -326,7 +355,7 @@
 	 * {@inheritDoc}
 	 */
 	protected Object entryInitialFlow() {
-		return new AnalysisInfo();
+		return domain.newMap();
 	}
 
 	/**
@@ -333,9 +362,9 @@
 	 * {@inheritDoc}
 	 */
 	protected void merge(Object in1, Object in2, Object out) {
-		AnalysisInfo left = (AnalysisInfo) in1;
-		AnalysisInfo right = (AnalysisInfo) in2;
-		AnalysisInfo res = (AnalysisInfo) out;
+		Map left = (Map) in1;
+		Map right = (Map) in2;
+		Map res = (Map) out;
 		
 		Set values = new HashSet();
 		values.addAll(left.keySet());
@@ -341,8 +370,6 @@
 		values.addAll(left.keySet());
 		values.addAll(right.keySet());
 		
-		res.clear();
-		
 		for (Iterator keyIter = values.iterator(); keyIter.hasNext();) {
 			Value v = (Value) keyIter.next();
 			Set leftAndRight = new HashSet();
@@ -377,7 +404,7 @@
 	 * {@inheritDoc}
 	 */
 	protected Object newInitialFlow() {
-		return new AnalysisInfo();
+		return domain.newMap();
 	}
 	
 	/**
@@ -388,8 +415,12 @@
 	 * @return true if i is always null right before this statement
 	 */
 	public boolean isAlwaysNullBefore(Unit s, Immediate i) {
-		AnalysisInfo ai = (AnalysisInfo) getFlowBefore(s);
-		return ai.get(i)==NULL;
+		if(i instanceof Local) {
+			Map ai = (Map) getFlowBefore(s);
+			return ai.get(i)==NULL;
+		} else {
+			return (i == NullConstant.v());
+		}
 	}
 
 	/**
@@ -400,36 +431,40 @@
 	 * @return true if i is always non-null right before this statement
 	 */
 	public boolean isAlwaysNonNullBefore(Unit s, Immediate i) {
-		AnalysisInfo ai = (AnalysisInfo) getFlowBefore(s);
-		return ai.get(i)==NON_NULL;
-	}
-
-	/**
-	 * The analysis info is a simple mapping of type {@link Value} to
-	 * any of the constants BOTTOM, NON_NULL, NULL or TOP.
-	 * This class returns BOTTOM by default.
-	 * 
-	 * @author Eric Bodden
-	 */
-	protected static class AnalysisInfo extends HashMap {
-		
-		public AnalysisInfo() {
-			super();
-		}
-
-		public AnalysisInfo(Map m) {
-			super(m);
-		}
-
-		public Object get(Object key) {
-			Object object = super.get(key);
-			if(object==null) {
-				return BOTTOM;
-			}
-			return object;
+		if(i instanceof Local) {
+			Map ai = (Map) getFlowBefore(s);
+			return ai.get(i)==NON_NULL;
+		} else {
+			return (i != NullConstant.v());
 		}
-		
 	}
+//
+//	/**
+//	 * The analysis info is a simple mapping of type {@link Value} to
+//	 * any of the constants BOTTOM, NON_NULL, NULL or TOP.
+//	 * This class returns BOTTOM by default.
+//	 * 
+//	 * @author Eric Bodden
+//	 */
+//	protected static class AnalysisInfo extends HashMap {
+//		
+//		public AnalysisInfo() {
+//			super();
+//		}
+//
+//		public AnalysisInfo(Map m) {
+//			super(m);
+//		}
+//
+//		public Object get(Object key) {
+//			Object object = super.get(key);
+//			if(object==null) {
+//				return BOTTOM;
+//			}
+//			return object;
+//		}
+//		
+//	}
 
 
 }
